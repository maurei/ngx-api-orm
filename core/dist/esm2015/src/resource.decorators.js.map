{"version":3,"file":"resource.decorators.js","sourceRoot":"","sources":["../package/src/resource.decorators.ts"],"names":[],"mappings":"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","sourcesContent":["import { Injectable } from '@angular/core';\nimport { Resource } from './resource.core';\nimport { RelationType, RelationConfiguration } from './relations/relation-configuration';\nimport { toDash, initMetaData, METAKEYS } from './utils';\n\n/**\n * Options object that can be passed to the {@link Model} when decorating your model. Currently it is only possible to configure `name`, which is used in\n * generating the urls for requests.\n *\n * If you have a custom `uglify.config.js` file in which `mangle` is set to false, you do not need to use this.\n *\n * If you don't, then Angular's AOT will obfuscate `constructor.name`, and this library will not be able to construct URL according to the name of your model.\n * To prevent this from happening, you can pass `name` in the decorator options.\n *\n * Alternatively, you can use `name` to provide for a custom representation in the url.\n *\n * @example\n * // uglify.config.js with mangle = false\n * @Model() // will produce calls to .../my-dummy-models/...\n * class MyDummyModel extends Resource {}\n *\n * // without mangle = false\n * @Model() // will not work!\n * class MyDummyModel extends Resource {}\n *\n * // without mangle = false\n * @Model({name: 'MyDummyModel'}) // will produce calls to .../my-dummy-models/...\n * class MyDummyModel extends Resource {}\n *\n * // without mangle = false\n * @Model({name: 'MyAlternativeName'}) // will produce calls to .../my-alternative-name/...\n * class MyDummyModel extends Resource {}\n *\n * // without mangle = false\n * @Model({name: 'my-alternative-name'}) // will produce calls to .../my-alternative-name/...\n * class MyDummyModel extends Resource {}\n */\nexport interface ModelOptions {\n\tname?: string;\n}\n/**\n * Add this class decorator to your model to turn it into a `Resource` model, which means that it is considered as an endpoint on your API.\n *\n * See {@link ModelOptions} on how to configure the name used in URLs.\n *\n * This decorator is responsible for setting metadata, which is used internally, on the constructor of your class.\n *\n * @param  ModelOptions={} options\n */\nexport function Model(options?: ModelOptions) {\n\treturn <T extends Resource>(ctor: any) => {\n\t\tctor = Injectable({ providedIn: 'root' })(ctor);\n\t\tinitMetaData(ctor);\n\t\tconst resourceName = options && options.name ? (options.name.includes('-') ? options.name : toDash(options.name)) : toDash(ctor.name);\n\t\tReflect.defineMetadata(METAKEYS.NAME, resourceName, ctor);\n\n\t\tconst fields = Reflect.getMetadata(METAKEYS.FIELDS, ctor);\n\t\tconst attributes = Reflect.getMetadata(METAKEYS.ATTRIBUTES, ctor);\n\t\tReflect.defineMetadata(METAKEYS.FIELDS, fields.concat(attributes), ctor);\n\n\t\treturn ctor;\n\t};\n}\n\n/**\n * Use this field decorator to parse the corresponding field from a json response by your API.\n * @param string mapFrom? An identifier to map keys coming from an incoming json response to keys in your model.\n *  For example: the api response has a key `commentText: 'nice article!` but the key in the model is `commentContent`.\n * Then the decorator should be used as `Field('commentText').\n */\nexport function Field(mapFrom?: string) {\n\treturn <T extends Resource>(target: any, key: string) => {\n\t\tconst ctor = target.constructor;\n\t\tinitMetaData(ctor);\n\t\tReflect.defineMetadata(METAKEYS.MAP, mapFrom, ctor, key);\n\t\tReflect.getMetadata(METAKEYS.ATTRIBUTES, ctor).push(key);\n\t};\n}\n\n/**\n * Use this field decorator to parse the corresponding field from a json response by your API and to identify the key as a To-One relationship.\n * @param Function RelatedResource The constructor function of the model that is targeted for the To-Many relation.\n * @param string mapFrom? An identifier to map keys coming from an incoming json response to keys in your model.\n *  For example: the api response has a key `commentText: 'nice article!` but the key in the model is `commentContent`.\n * Then the decorator should be used as `Field('commentText').\n */\nexport const ToOne = function<TRelated extends Resource>(RelatedResource: any, mapFrom?: string) {\n\treturn (target: any, key: string) => {\n\t\tconst ctor = target.constructor;\n\t\tinitMetaData(ctor);\n\t\tReflect.defineMetadata(METAKEYS.MAP, mapFrom, ctor, key);\n\t\tReflect.getMetadata(METAKEYS.FIELDS, ctor).push(key);\n\t\tReflect.getMetadata(METAKEYS.RELATIONS, ctor)[key] = new RelationConfiguration(ctor, RelatedResource, key, RelationType.ToOne);\n\t};\n};\n\n/**\n * Use this field decorator to parse the corresponding field from a json response by your API and to identify the key as a To-Many relationship.\n * @param Function RelatedResource The constructor function of the model that is targeted for the To-Many relation.\n * @param string mapFrom? An identifier to map keys coming from an incoming json response to keys in your model.\n *  For example: the api response has a key `commentText: 'nice article!` but the key in the model is `commentContent`.\n * Then the decorator should be used as `Field('commentText').\n */\nexport const ToMany = function <TRelated extends Resource>(RelatedResource: any, mapFrom?: string) {\n\treturn (target: any, key: string) => {\n\t\tconst ctor = target.constructor;\n\t\tinitMetaData(ctor);\n\t\tReflect.defineMetadata(METAKEYS.MAP, mapFrom, ctor, key);\n\t\tReflect.getMetadata(METAKEYS.FIELDS, ctor).push(key);\n\t\tReflect.getMetadata(METAKEYS.RELATIONS, ctor)[key] = new RelationConfiguration(ctor, RelatedResource, key, RelationType.ToMany);\n\t};\n};\n"]}